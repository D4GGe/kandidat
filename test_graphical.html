



<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="500" height="500" style="border-style: solid;
    border-width: 5px;"></canvas>
    
  <script src="http://349.se/gauss.js"></script>
  <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script src="http://numericjs.com/lib/numeric-1.2.6.min.js"></script>
    <script>
    /*
    ------------------info------------------
    For matrix operations and so on. http://numericjs.com/documentation.html
    For basic math http://www.w3schools.com/jsref/jsref_obj_math.asp


     the '/' in matlab or gauss elemenitation  is preformd like folows:     

     * Solves this system:
     * x + y + z = 6
     * 2x + y + 2z = 10
     * x + 2y + 3z = 14
        A = [[1, 1, 1],
              [2, 1, 2], 
              [1, 2, 3]];

        x = [6, 10, 14];
        result = gauss($A, $x);
    */






////////////  helpers by Daniel ////////////////////////////////////
    function plotLine(can , matrix){
      var context = can.getContext('2d');
      context.beginPath();
      context.moveTo(mathToWebCord(matrix[0],can.height)[0],mathToWebCord(matrix[0],can.height)[1]);
      for (var i = 0; i <= matrix.length - 1; i++) {  
          context.lineTo(mathToWebCord(matrix[i],can.height)[0],mathToWebCord(matrix[i],can.height)[1]);
      };
      context.stroke();
    }

    function plotPoints(can , matrix,size){
      var context = can.getContext('2d');   
      for (var i = 0; i <= matrix.length - 1; i++) {  
          context.beginPath();
          context.arc(mathToWebCord(matrix[i],can.height)[0], mathToWebCord(matrix[i],can.height)[1], size, 0, 2 * Math.PI, true);
          
          context.fill();
          
      };
      
    }

     function mathToWebCord(cord,ySize){
      x = cord[0];
      y = cord[1];
      return [x,ySize-y];
     }

     function webToMathCord(cord,ySize){
      x = cord[0];
      y = cord[1];
      return [x,y-ySize];
     
     }

     function createMatrix(start,end,inc,func){
      var ans = [];
      for (var i = start; i<=end; i=i+inc) {
        ans.push([i,func(i)]);
        console.log(i);
      };
      return ans;
     }


///////////////////////////////////////////////////////////////////////////
        



        (function (){
          function graphObj(type){
            var self = this;
            this.type = type;
            this.img = arrow;
            this.x = 0;
            this.y = 0;
            this.height = 40;
            this.width = 40;
            this.draw = function(){
              context.beginPath();
              context.drawImage(self.img,self.x,self.y,self.height,self.width);
            };
            this.draw();

            this.isInside = function(x,y){
              return x>self.x && x<(self.x+self.width) && y>self.y && y<(self.y+self.height);
            };

            this.moveTo = function(x,y){
              context.beginPath();
              context.fillStyle = "#FFFFFF";
              context.fillRect(self.x,self.y,self.width,self.height);
              self.x = x;
              self.y = y;
              self.draw();
            };
          }

          function listGraphObj(){
            var self = this;
            this.list = new Array();
            this.add = function(graphObj){
              self.list.push(graphObj);
            };

            this.delete = function (obj){
              console.log('delet is not implemented yet');
              // Object.is(value1, value2);
            };
            
            this.findByCord = function(x,y){
              for (var i = 0 ; i < self.list.length; i++) {
                if(self.list[i].isInside(x,y)){
                  return self.list[i];
                }
              };
              return false;
            };

          }

          function canHandler(listo){
            ofx = 0;
            ofy = 0;
            self = this;
            this.listGraphObj = listo;
            this.graphObj = false;
            this.onClick = function(x,y){
              self.graphObj = self.listGraphObj.findByCord(x,y);
              if(self.graphObj){
                self.ofx=x-self.graphObj.x;
                self.ofy=y-self.graphObj.y;
                console.log(self.ofx);
                console.log(self.ofy);
              }
            };
            this.onMove = function(x,y){
              if(self.graphObj){
                self.graphObj.moveTo(x-self.ofx,y-self.ofy);
              }
            };
            this.onUpp = function(){
              self.graphObj = false;
            };

          }

        var canvas = document.getElementById('myCanvas');
        

            function getMousePos(canvas, evt) {
              var rect = canvas.getBoundingClientRect();
                return {
                  x: evt.clientX - rect.left,
                  y: evt.clientY - rect.top
                };
              }

        // Set up our canvas on the page before doing anything.  
        // Get drawing context for the Canvas
        var context = canvas.getContext('2d');
          
        // Load up our image.
        var arrow = new Image();
        arrow.src = 'http://sbstechnologies.in/Workshop/Brushed/Source%20Files/ICONS%20+%20FONT/Icons/SVG/arrow-round-left.svg';
        arrow.width = '100';
        arrow.height = '100';
        // Render our SVG image to the canvas once it loads.
        arrow.onload = function(){
            var arr = new graphObj('type');
            var listob = new  listGraphObj();
            listob.add(arr);
            var canHan = new canHandler(listob);

            canvas.addEventListener("mousedown", function msdwn(evt){
                 var mousePos = getMousePos(canvas, evt);
                 canHan.onClick(mousePos.x,mousePos.y);
            }, false);

            canvas.addEventListener('mousemove', function(evt) {
                var mousePos = getMousePos(canvas, evt);
                canHan.onMove(mousePos.x,mousePos.y);
                }, false);
            canvas.addEventListener('mouseup', function(evt) {
                canHan.onUpp();
                //arr.moveTo(mousePos.x,mousePos.y);
                }, false);
                 
              }

        })();
        
        
        //var testcon = canvas.getContext('2d');
        //plotPoints(canvas,A, 10);
        //plotLine(canvas,A);
     // var context = canvas.getContext('2d');
     // context.beginPath();
     // context.moveTo(100, 150);
     // context.lineTo(450, 50);
     // context.stroke();
    </script>
  </body>
</html>     